// Copyright (C) Moondance Labs Ltd.
// This file is part of Tanssi.

// Tanssi is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Tanssi is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Tanssi.  If not, see <http://www.gnu.org/licenses/>

//! # Migrations
//!
//! This module acts as a registry where each migration is defined. Each migration should implement
//! the "Migration" trait declared in the pallet-migrations crate.

use {
    crate::{Invulnerables, ParaId, Runtime, RuntimeOrigin, ServicesPayment, LOG_TARGET},
    frame_support::{
        migration::storage_key_iter, pallet_prelude::ValueQuery, storage::types::StorageMap,
        storage::types::StorageValue, traits::OnRuntimeUpgrade, weights::Weight, Blake2_128Concat,
    },
    pallet_balances::IdAmount,
    pallet_configuration::{weights::WeightInfo as _, HostConfiguration},
    pallet_invulnerables::weights::WeightInfo as _,
    pallet_migrations::{GetMigrations, Migration},
    sp_core::Get,
    sp_runtime::BoundedVec,
    sp_std::{collections::btree_set::BTreeSet, marker::PhantomData, prelude::*},
};

#[derive(
    Clone,
    parity_scale_codec::Encode,
    parity_scale_codec::Decode,
    PartialEq,
    sp_core::RuntimeDebug,
    scale_info::TypeInfo,
)]
struct HostConfigurationV0 {
    pub max_collators: u32,
    pub min_orchestrator_collators: u32,
    pub max_orchestrator_collators: u32,
    pub collators_per_container: u32,
}

pub struct CollatorSelectionStorageValuePrefix;
impl frame_support::traits::StorageInstance for CollatorSelectionStorageValuePrefix {
    const STORAGE_PREFIX: &'static str = "Invulnerables";
    fn pallet_prefix() -> &'static str {
        "CollatorSelection"
    }
}
pub type CollatorSelectionInvulnerablesValue<T> = StorageValue<
    CollatorSelectionStorageValuePrefix,
    BoundedVec<
        <T as frame_system::Config>::AccountId,
        <T as pallet_invulnerables::Config>::MaxInvulnerables,
    >,
>;

pub struct MigrateInvulnerables<T>(pub PhantomData<T>);
impl<T> Migration for MigrateInvulnerables<T>
where
    T: pallet_invulnerables::Config,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateInvulnerables"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        log::info!(target: LOG_TARGET, "migrate");

        let invulnerables = CollatorSelectionInvulnerablesValue::<Runtime>::take()
            .expect("Failed to get invulnerables from CollatorSelection pallet storage.");
        let invulnerables_len = invulnerables.len();
        Invulnerables::set_invulnerables(RuntimeOrigin::root(), invulnerables.to_vec())
            .expect("Failed to set invulnerables");
        <T as pallet_invulnerables::Config>::WeightInfo::set_invulnerables(invulnerables_len as u32)
    }

    /// Run a standard pre-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn pre_upgrade(&self) -> Result<Vec<u8>, sp_runtime::DispatchError> {
        log::info!(target: LOG_TARGET, "pre_upgrade");

        use parity_scale_codec::Encode;

        let number_of_invulnerables = CollatorSelectionInvulnerablesValue::<Runtime>::get()
            .expect("Failed to get invulnerables from CollatorSelection pallet storage.")
            .to_vec()
            .len();
        Ok((number_of_invulnerables as u32).encode())
    }

    /// Run a standard post-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn post_upgrade(
        &self,
        number_of_invulnerables: Vec<u8>,
    ) -> Result<(), sp_runtime::DispatchError> {
        log::info!(target: LOG_TARGET, "post_upgrade");
        use parity_scale_codec::Decode;

        let stored_invulnerables = Invulnerables::invulnerables().to_vec();
        let mut sorted_invulnerables = stored_invulnerables.clone();
        sorted_invulnerables.sort();
        assert_eq!(
            stored_invulnerables, sorted_invulnerables,
            "after migration, the stored invulnerables should be sorted"
        );

        let number_of_invulnerables: u32 = Decode::decode(&mut number_of_invulnerables.as_slice())
            .expect("the state parameter should be something that was generated by pre_upgrade");
        let stored_invulnerables_len = stored_invulnerables.len() as u32;
        assert_eq!(
            number_of_invulnerables, stored_invulnerables_len,
            "after migration, there should be the same number of invulnerables"
        );

        Ok(())
    }
}

pub struct MigrateHoldReason<T>(pub PhantomData<T>);
impl<T> Migration for MigrateHoldReason<T>
where
    T: pallet_balances::Config,
    T: pallet_pooled_staking::Config,
    <T as pallet_balances::Config>::RuntimeHoldReason: From<pallet_pooled_staking::HoldReason>,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateHoldReason"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        log::info!(target: LOG_TARGET, "migrate");
        let pallet_prefix: &[u8] = b"Balances";
        let storage_item_prefix: &[u8] = b"Holds";

        let stored_data: Vec<_> = storage_key_iter::<
            T::AccountId,
            BoundedVec<IdAmount<[u8; 8], <T as pallet_balances::Config>::Balance>, T::MaxHolds>,
            Blake2_128Concat,
        >(pallet_prefix, storage_item_prefix)
        .collect();

        let migrated_count_read = stored_data.len() as u64;
        let mut migrated_count_write = 0u64;

        // Write to the new storage
        for (account_id, holds) in stored_data {
            let mut new_holds = vec![];

            for hold in holds {
                let new_item: pallet_balances::IdAmount<
                    <T as pallet_balances::Config>::RuntimeHoldReason,
                    <T as pallet_balances::Config>::Balance,
                > = pallet_balances::IdAmount {
                    id: pallet_pooled_staking::HoldReason::PooledStake.into(),
                    amount: hold.amount,
                };
                new_holds.push(new_item);
            }
            let bounded = BoundedVec::<_, T::MaxHolds>::truncate_from(new_holds.clone());
            pallet_balances::Holds::<T>::insert(&account_id, bounded);
            migrated_count_write += 1;
        }
        let db_weights = T::DbWeight::get();
        db_weights.reads_writes(migrated_count_read, migrated_count_write)
    }

    /// Run a standard pre-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn pre_upgrade(&self) -> Result<Vec<u8>, sp_runtime::DispatchError> {
        log::info!(target: LOG_TARGET, "pre_upgrade");
        let pallet_prefix: &[u8] = b"Balances";
        let storage_item_prefix: &[u8] = b"Holds";

        let stored_data: Vec<_> = storage_key_iter::<
            T::AccountId,
            BoundedVec<IdAmount<[u8; 8], <T as pallet_balances::Config>::Balance>, T::MaxHolds>,
            Blake2_128Concat,
        >(pallet_prefix, storage_item_prefix)
        .collect();
        use parity_scale_codec::Encode;

        Ok(stored_data.encode())
    }

    /// Run a standard post-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn post_upgrade(&self, migrated_holds: Vec<u8>) -> Result<(), sp_runtime::DispatchError> {
        use parity_scale_codec::Decode;
        let should_be_migrated: Vec<(
            T::AccountId,
            BoundedVec<IdAmount<[u8; 8], <T as pallet_balances::Config>::Balance>, T::MaxHolds>,
        )> = Decode::decode(&mut migrated_holds.as_slice()).expect("should be decodable");

        log::info!(target: LOG_TARGET, "post_upgrade");

        // Write to the new storage
        for (account_id, holds) in should_be_migrated {
            let migrated = pallet_balances::Holds::<T>::get(&account_id);

            for (index, hold) in holds.iter().enumerate() {
                assert_eq!(
                    migrated[index].amount, hold.amount,
                    "after migration, there should be the same number held amount"
                );
                assert_eq!(
                    migrated[index].id,
                    pallet_pooled_staking::HoldReason::PooledStake.into(),
                    "Pooled stake should be migrated"
                );
            }
        }

        Ok(())
    }
}

pub struct MigrateConfigurationFullRotationPeriod<T>(pub PhantomData<T>);
impl<T> Migration for MigrateConfigurationFullRotationPeriod<T>
where
    T: pallet_configuration::Config,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateConfigurationFullRotationPeriod"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        log::info!(target: LOG_TARGET, "migrate");

        const CONFIGURATION_ACTIVE_CONFIG_KEY: &[u8] =
            &hex_literal::hex!("06de3d8a54d27e44a9d5ce189618f22db4b49d95320d9021994c850f25b8e385");
        const CONFIGURATION_PENDING_CONFIGS_KEY: &[u8] =
            &hex_literal::hex!("06de3d8a54d27e44a9d5ce189618f22d53b4123b2e186e07fb7bad5dda5f55c0");

        // Modify active config
        let old_config: HostConfigurationV0 =
            frame_support::storage::unhashed::get(CONFIGURATION_ACTIVE_CONFIG_KEY)
                .expect("configuration.activeConfig should have value");
        let new_config = HostConfiguration {
            max_collators: old_config.max_collators,
            min_orchestrator_collators: old_config.min_orchestrator_collators,
            max_orchestrator_collators: old_config.max_orchestrator_collators,
            collators_per_container: old_config.collators_per_container,
            full_rotation_period: 0,
        };
        frame_support::storage::unhashed::put(CONFIGURATION_ACTIVE_CONFIG_KEY, &new_config);

        // Modify pending configs, if any
        let old_pending_configs: Vec<(u32, HostConfigurationV0)> =
            frame_support::storage::unhashed::get(CONFIGURATION_PENDING_CONFIGS_KEY)
                .unwrap_or_default();
        let mut new_pending_configs: Vec<(u32, HostConfiguration)> = vec![];

        for (session_index, old_config) in old_pending_configs {
            let new_config = HostConfiguration {
                max_collators: old_config.max_collators,
                min_orchestrator_collators: old_config.min_orchestrator_collators,
                max_orchestrator_collators: old_config.max_orchestrator_collators,
                collators_per_container: old_config.collators_per_container,
                full_rotation_period: 0,
            };
            new_pending_configs.push((session_index, new_config));
        }

        if !new_pending_configs.is_empty() {
            frame_support::storage::unhashed::put(
                CONFIGURATION_PENDING_CONFIGS_KEY,
                &new_pending_configs,
            );
        }

        <T as pallet_configuration::Config>::WeightInfo::set_config_with_u32()
    }

    /// Run a standard pre-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn pre_upgrade(&self) -> Result<Vec<u8>, sp_runtime::DispatchError> {
        const CONFIGURATION_ACTIVE_CONFIG_KEY: &[u8] =
            &hex_literal::hex!("06de3d8a54d27e44a9d5ce189618f22db4b49d95320d9021994c850f25b8e385");

        let old_config_bytes =
            frame_support::storage::unhashed::get_raw(CONFIGURATION_ACTIVE_CONFIG_KEY)
                .expect("configuration.activeConfig should have value");
        assert_eq!(old_config_bytes.len(), 16);

        use parity_scale_codec::Encode;
        Ok((old_config_bytes).encode())
    }

    /// Run a standard post-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn post_upgrade(
        &self,
        _number_of_invulnerables: Vec<u8>,
    ) -> Result<(), sp_runtime::DispatchError> {
        let new_period = crate::Configuration::config().full_rotation_period;
        assert_eq!(new_period, 24);

        Ok(())
    }
}

pub struct PolkadotXcmMigration<T>(pub PhantomData<T>);
impl<T> Migration for PolkadotXcmMigration<T>
where
    T: pallet_xcm::Config,
{
    fn friendly_name(&self) -> &str {
        "MM_PolkadotXcmMigration"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        pallet_xcm::migration::v1::VersionUncheckedMigrateToV1::<T>::on_runtime_upgrade()
    }
}

pub struct XcmpQueueMigration<T>(pub PhantomData<T>);
impl<T> Migration for XcmpQueueMigration<T>
where
    T: cumulus_pallet_xcmp_queue::Config,
{
    fn friendly_name(&self) -> &str {
        "MM_XcmpQueueMigration"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        cumulus_pallet_xcmp_queue::migration::Migration::<T>::on_runtime_upgrade()
    }
}

pub struct MigrateServicesPaymentAddCredits<T>(pub PhantomData<T>);
impl<T> Migration for MigrateServicesPaymentAddCredits<T>
where
    T: cumulus_pallet_xcmp_queue::Config,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateServicesPaymentAddCredits"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        // For each parachain in pallet_registrar (active, pending or pending_verification),
        // insert `MaxCreditsStored` to pallet_services_payment,
        // and mark that parachain as "given_free_credits".
        let mut para_ids = BTreeSet::new();
        let active = pallet_registrar::RegisteredParaIds::<Runtime>::get();
        let pending = pallet_registrar::PendingParaIds::<Runtime>::get();
        let pending_verification = pallet_registrar::PendingVerification::<Runtime>::get();
        // This migration ignores Paused and PendingPaused because they do not exist yet in dancebox

        para_ids.extend(active);
        para_ids.extend(pending.into_iter().flat_map(|(_session, active)| active));
        para_ids.extend(pending_verification);

        let reads = 3 + 2 * para_ids.len() as u64;
        let writes = 2 * para_ids.len() as u64;

        for para_id in para_ids {
            // 2 reads 2 writes
            ServicesPayment::give_free_credits(&para_id);
        }

        let db_weights = T::DbWeight::get();
        db_weights.reads_writes(reads, writes)
    }
}

/// A reason for placing a hold on funds.
#[derive(
    Clone,
    parity_scale_codec::Encode,
    parity_scale_codec::Decode,
    PartialEq,
    sp_core::RuntimeDebug,
    scale_info::TypeInfo,
)]
pub enum OldHoldReason {
    /// The Pooled Stake holds
    PooledStake,
}

pub struct MigrateHoldReasonRuntimeEnum<T>(pub PhantomData<T>);
impl<T> Migration for MigrateHoldReasonRuntimeEnum<T>
where
    T: pallet_balances::Config,
    T: pallet_pooled_staking::Config,
    <T as pallet_balances::Config>::RuntimeHoldReason: From<pallet_pooled_staking::HoldReason>,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateHoldReasonRuntimeHold"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        log::info!(target: LOG_TARGET, "migrate");
        let pallet_prefix: &[u8] = b"Balances";
        let storage_item_prefix: &[u8] = b"Holds";

        let stored_data: Vec<_> = storage_key_iter::<
            T::AccountId,
            BoundedVec<
                IdAmount<OldHoldReason, <T as pallet_balances::Config>::Balance>,
                T::MaxHolds,
            >,
            Blake2_128Concat,
        >(pallet_prefix, storage_item_prefix)
        .collect();

        let migrated_count_read = stored_data.len() as u64;
        let mut migrated_count_write = 0u64;

        // Write to the new storage
        for (account_id, holds) in stored_data {
            let mut new_holds = vec![];

            for hold in holds {
                let new_item: pallet_balances::IdAmount<
                    <T as pallet_balances::Config>::RuntimeHoldReason,
                    <T as pallet_balances::Config>::Balance,
                > = pallet_balances::IdAmount {
                    id: pallet_pooled_staking::HoldReason::PooledStake.into(),
                    amount: hold.amount,
                };
                new_holds.push(new_item);
            }
            let bounded = BoundedVec::<_, T::MaxHolds>::truncate_from(new_holds.clone());
            pallet_balances::Holds::<T>::insert(&account_id, bounded);
            migrated_count_write += 1;
        }
        let db_weights = T::DbWeight::get();
        db_weights.reads_writes(migrated_count_read, migrated_count_write)
    }

    /// Run a standard pre-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn pre_upgrade(&self) -> Result<Vec<u8>, sp_runtime::DispatchError> {
        log::info!(target: LOG_TARGET, "pre_upgrade");
        let pallet_prefix: &[u8] = b"Balances";
        let storage_item_prefix: &[u8] = b"Holds";

        let stored_data: Vec<_> = storage_key_iter::<
            T::AccountId,
            BoundedVec<
                IdAmount<OldHoldReason, <T as pallet_balances::Config>::Balance>,
                T::MaxHolds,
            >,
            Blake2_128Concat,
        >(pallet_prefix, storage_item_prefix)
        .collect();
        use parity_scale_codec::Encode;

        Ok(stored_data.encode())
    }

    /// Run a standard post-runtime test. This works the same way as in a normal runtime upgrade.
    #[cfg(feature = "try-runtime")]
    fn post_upgrade(&self, migrated_holds: Vec<u8>) -> Result<(), sp_runtime::DispatchError> {
        use parity_scale_codec::Decode;
        let should_be_migrated: Vec<(
            T::AccountId,
            BoundedVec<
                IdAmount<OldHoldReason, <T as pallet_balances::Config>::Balance>,
                T::MaxHolds,
            >,
        )> = Decode::decode(&mut migrated_holds.as_slice()).expect("should be decodable");

        // Write to the new storage
        for (account_id, holds) in should_be_migrated {
            let migrated = pallet_balances::Holds::<T>::get(&account_id);

            for (index, hold) in holds.iter().enumerate() {
                assert_eq!(
                    migrated[index].amount, hold.amount,
                    "after migration, there should be the same number held amount"
                );
                assert_eq!(
                    migrated[index].id,
                    pallet_pooled_staking::HoldReason::PooledStake.into(),
                    "Pooled stake should be migrated"
                );
            }
        }

        Ok(())
    }
}

pub struct RegistrarBootNodesStorageValuePrefix<T>(PhantomData<T>);
impl<T> frame_support::traits::StorageInstance for RegistrarBootNodesStorageValuePrefix<T> {
    const STORAGE_PREFIX: &'static str = "BootNodes";
    fn pallet_prefix() -> &'static str {
        "Registrar"
    }
}
pub type RegistrarBootNodesStorageMap<T> = StorageMap<
    RegistrarBootNodesStorageValuePrefix<T>,
    Blake2_128Concat,
    ParaId,
    //BoundedVec<BoundedVec<u8, T::MaxBootNodeUrlLen>, T::MaxBootNodes>,
    Vec<Vec<u8>>,
    ValueQuery,
>;

pub struct MigrateBootNodes<T>(pub PhantomData<T>);
impl<T> Migration for MigrateBootNodes<T>
where
    T: cumulus_pallet_xcmp_queue::Config,
{
    fn friendly_name(&self) -> &str {
        "TM_MigrateBootNodes"
    }

    fn migrate(&self, _available_weight: Weight) -> Weight {
        let mut len = 0;
        for (para_id, bootnodes) in RegistrarBootNodesStorageMap::<Runtime>::drain() {
            len += 1;
            // Convert Vec<Vec<u8>> into BoundedVec<BoundedVec<u8>>
            // Cannot fail because the old storage was actually a BoundedVec with the same limit as the new one
            let bootnodes: Vec<_> = bootnodes
                .into_iter()
                .map(|bootnode| bootnode.try_into().unwrap())
                .collect();
            let bootnodes: BoundedVec<_, _> = bootnodes.try_into().unwrap();
            pallet_data_preservers::BootNodes::<Runtime>::insert(para_id, bootnodes);
        }

        let db_weights = T::DbWeight::get();
        let reads = len;
        let writes = len;
        db_weights.reads_writes(reads, writes)
    }
}

pub struct DanceboxMigrations<Runtime>(PhantomData<Runtime>);

impl<Runtime> GetMigrations for DanceboxMigrations<Runtime>
where
    Runtime: pallet_invulnerables::Config,
    Runtime: pallet_pooled_staking::Config,
    Runtime: pallet_balances::Config,
    Runtime: pallet_configuration::Config,
    Runtime: pallet_xcm::Config,
    Runtime: cumulus_pallet_xcmp_queue::Config,
    <Runtime as pallet_balances::Config>::RuntimeHoldReason:
        From<pallet_pooled_staking::HoldReason>,
{
    fn get_migrations() -> Vec<Box<dyn Migration>> {
        //let migrate_invulnerables = MigrateInvulnerables::<Runtime>(Default::default());
        //let migrate_holds = MigrateHoldReason::<Runtime>(Default::default());
        //let migrate_config = MigrateConfigurationFullRotationPeriod::<Runtime>(Default::default());
        //let migrate_xcm = PolkadotXcmMigration::<Runtime>(Default::default());
        // let migrate_xcmp_queue = XcmpQueueMigration::<Runtime>(Default::default());
        let migrate_services_payment =
            MigrateServicesPaymentAddCredits::<Runtime>(Default::default());
        let migrate_boot_nodes = MigrateBootNodes::<Runtime>(Default::default());

        let migrate_hold_reason_runtime_enum =
            MigrateHoldReasonRuntimeEnum::<Runtime>(Default::default());
        vec![
            // Applied in runtime 200
            //Box::new(migrate_invulnerables),
            // Applied in runtime 200
            //Box::new(migrate_holds),
            // Applied in runtime 300
            //Box::new(migrate_config),
            // Applied in runtime 300
            //Box::new(migrate_xcm),
            // Applied in runtime 300
            //Box::new(migrate_xcmp_queue),
            Box::new(migrate_services_payment),
            Box::new(migrate_hold_reason_runtime_enum),
            Box::new(migrate_boot_nodes),
        ]
    }
}
