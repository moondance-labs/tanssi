// Copyright (C) Moondance Labs Ltd.
// This file is part of Tanssi.

// Tanssi is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Tanssi is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Tanssi.  If not, see <http://www.gnu.org/licenses/>

//! A staking pallet based on pools of shares.
//!
//! This pallet works with pools inspired by AMM liquidity pools to easily distribute
//! rewards with support for both non-compounding and compounding rewards.
//!
//! Each candidate internally have 3 pools:
//! - a pool for all delegators willing to auto compound.
//! - a pool for all delegators not willing to auto compound.
//! - a pool for all delegators that are in the process of removing stake.
//!
//! When delegating the funds of the delegator are reserved, and shares allow to easily
//! distribute auto compounding rewards (by simply increasing the total shared amount)
//! and easily slash (each share loose part of its value). Rewards are distributed to an account
//! id dedicated to the staking pallet, and delegators can call an extrinsic to transfer their rewards
//! to their own account (but as reserved). Keeping funds reserved in user accounts allow them to
//! participate in other processes such as gouvernance.

#![cfg_attr(not(feature = "std"), no_std)]

mod calls;
mod candidate;
mod pools;
pub mod traits;

use frame_support::pallet;

pub use pallet::*;

#[pallet]
pub mod pallet {
    use {
        super::*,
        core::marker::PhantomData,
        frame_support::{
            storage::types::{StorageDoubleMap, StorageValue, ValueQuery},
            traits::{fungible, tokens::Balance, IsType},
            Blake2_128Concat, RuntimeDebug,
        },
        parity_scale_codec::{Decode, Encode, FullCodec},
        scale_info::TypeInfo,
        sp_core::Get,
        sp_runtime::{BoundedVec, Perbill},
        sp_std::collections::btree_set::BTreeSet,
    };

    #[cfg(feature = "std")]
    use serde::{Deserialize, Serialize};

    // Type aliases for better readability.
    pub type Candidate<T> = <T as frame_system::Config>::AccountId;
    pub type Delegator<T> = <T as frame_system::Config>::AccountId;

    /// Allow to customize when requests can be executed.
    pub trait RequestFilter<T: Config> {
        fn can_be_executed(
            candidate: &Candidate<T>,
            delegator: &Delegator<T>,
            request_block: T::BlockNumber,
        ) -> bool;
    }

    /// Key used by the `Pools` StorageDoubleMap, avoiding lots of maps.
    /// StorageDoubleMap first key is the account id of the candidate.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub enum PoolsKey<A: FullCodec> {
        /// Total amount of currency backing this candidate across all pools.
        CandidateTotalStake,

        /// Amount of joining shares a delegator have for that candidate.
        JoiningShares { delegator: A },
        /// Total amount of joining shares existing for that candidate.
        JoiningSharesSupply,
        /// Amount of currency backing all the auto compounding shares of that candidate.
        JoiningSharesTotalStaked,

        /// Amount of auto compounding shares a delegator have for that candidate.
        AutoCompoundingShares { delegator: A },
        /// Total amount of auto compounding shares existing for that candidate.
        AutoCompoundingSharesSupply,
        /// Amount of currency backing all the auto compounding shares of that candidate.
        AutoCompoundingSharesTotalStaked,

        /// Amount of manual rewards shares a delegator have for that candidate.
        ManualRewardsShares { delegator: A },
        /// Total amount of manual rewards shares existing for that candidate.
        ManualRewardsSharesSupply,
        /// Amount of currency backing all the manual rewards shares of that candidate.
        ManualRewardsTotalStaked,
        /// Counter of the cumulated rewards per share generated by that candidate since genesis.
        /// Is safe to wrap around the maximum value of the balance type.
        ManualRewardsCounter,
        /// Value of the counter at the last time the delegator claimed its rewards or changed its amount of shares
        /// (changing the amount of shares automatically claims pending rewards).
        /// The difference between the checkpoint and the counter is the amount of claimable reward per share for
        /// that delegator.
        ManualRewardsCheckpoint { delegator: A },

        /// Amount of shares of that delegator in the leaving pool of that candidate.
        /// When leaving delegating funds are placed in the leaving pool until the leaving period is elapsed.
        /// While in the leaving pool the funds are still slashable.
        LeavingShares { delegator: A },
        /// Total amount of leaving shares existing for that candidate.
        LeavingSharesSupply,
        /// Amount of currency backing all the leaving shares of that candidate.
        LeavingSharesTotalStaked,
    }

    /// Key used by the "PendingOperations" StorageDoubleMap.
    /// StorageDoubleMap first key is the account id of the delegator who made the request.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub enum PendingOperationKey<A: FullCodec, B: FullCodec> {
        /// Candidate requested to join the auto compounding pool of a candidate.
        JoiningAutoCompounding { candidate: A, at_block: B },
        /// Candidate requested to join the manual rewards pool of a candidate.
        JoiningManualRewards { candidate: A, at_block: B },
        /// Candidate requested to to leave a pool of a candidate.
        Leaving { candidate: A, at_block: B },
    }

    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub struct PendingOperationQuery<A: FullCodec, B: FullCodec> {
        pub delegator: A,
        pub operation: PendingOperationKey<A, B>,
    }

    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Copy, Clone, TypeInfo)]
    pub enum TargetPool {
        AutoCompounding,
        ManualRewards,
    }

    /// Allow calls to be performed using either share amounts or stake.
    /// When providing stake, calls will convert them into share amounts that are
    /// worth up to the provided stake. The amount of stake thus will be at most the provided
    /// amount.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub enum SharesOrStake<T> {
        Shares(T),
        Stake(T),
    }

    /// Wrapper type for an amount of shares.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Copy, Clone, TypeInfo)]
    pub struct Shares<T: Config>(pub T::Balance);

    /// Wrapper type for an amount of staked currency.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Copy, Clone, TypeInfo)]
    pub struct Stake<T: Config>(pub T::Balance);

    /// Pooled Staking pallet.
    #[pallet::pallet]
    #[pallet::without_storage_info]
    pub struct Pallet<T>(PhantomData<T>);

    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// Overarching event type
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        /// The currency type.
        /// Shares will use the same Balance type.
        type Currency: fungible::Inspect<Self::AccountId, Balance = Self::Balance>
            + fungible::Mutate<Self::AccountId>
            + fungible::hold::Mutate<Self::AccountId>;

        /// Same as Currency::Balance. Must impl `MulDiv` which perform
        /// multiplication followed by division using a bigger type to avoid
        /// overflows.
        type Balance: Balance + traits::MulDiv;

        /// Identifier reserved for this pallet holding account funds.
        type CurrencyHoldReason: Get<
            <Self::Currency as fungible::hold::Inspect<Self::AccountId>>::Reason,
        >;

        /// Account holding Currency of all delegators.
        type StakingAccount: Get<Self::AccountId>;
        /// Account of the reserve.
        type ReserveAccount: Get<Self::AccountId>;

        /// When creating the first Shares for a candidate the supply can be arbitrary.
        /// Picking a value too low will make an higher supply, which means each share will get
        /// less rewards, and rewards calculations will have more impactful rounding errors.
        /// Picking a value too high is a barrier of entry for staking.
        type InitialManualClaimShareValue: Get<Self::Balance>;
        /// When creating the first Shares for a candidate the supply can arbitrary.
        /// Picking a value too high is a barrier of entry for staking, which will increase overtime
        /// as the value of each share will increase due to auto compounding.
        type InitialAutoCompoundingShareValue: Get<Self::Balance>;
        /// Minimum amount of stake a Candidate must delegate (stake) towards itself. Not reaching
        /// this minimum prevents from being elected.
        type MinimumSelfDelegation: Get<Self::Balance>;
        /// When leaving staking the stake is put into leaving pools, and the share of this pool
        /// is stored alongside the current BlockNumber. The user will be able to withdraw the stake
        /// represented by those shares once LeavingDelay has passed.
        /// Shares are used here to allow slashing, as while leaving stake is no longer used for
        /// elections and rewards they must still be at stake in case the candidate misbehave.
        type LeavingDelay: Get<Self::BlockNumber>;

        /// Part of the rewards that will be sent to the reserve.
        type RewardsReserveCommission: Get<Perbill>;
        /// Part of the rewards that will be sent exclusively to the collator.
        type RewardsCollatorCommission: Get<Perbill>;

        /// Condition for when a joining request can be executed.
        type JoiningRequestFilter: RequestFilter<Self>;
        /// Condition for when a leaving request can be executed.
        type LeavingRequestFilter: RequestFilter<Self>;
        /// All eligible candidates are stored in a sorted list that is modified each time
        /// delegations changes. It is safer to bound this list, in which case eligible candidate
        /// could fall out of this list if they have less stake than the top `EligibleCandidatesBufferSize`
        /// eligible candidates. One of this top candidates leaving will then not bring the dropped candidate
        /// in the list. An extrinsic is available (TODO) to manually bring back such dropped candidate.
        type EligibleCandidatesBufferSize: Get<u32>;
    }

    /// The final set of collators.
    /// Is the top `MaxCollatorSetSize` of `SortedEligibleCandidates`.
    #[pallet::storage]
    pub type CollatorSet<T: Config> = StorageValue<_, BTreeSet<Candidate<T>>, ValueQuery>;

    /// Maximum size of the collator set.
    #[pallet::storage]
    pub type MaxCollatorSetSize<T: Config> = StorageValue<_, u32, ValueQuery>;

    /// Keeps a list of all eligible candidates, sorted by the amount of stake backing them.
    /// This can be quickly updated using a binary search, and allow to easily take the top
    /// `MaxCollatorSetSize`.
    #[pallet::storage]
    pub type SortedEligibleCandidates<T: Config> = StorageValue<
        _,
        BoundedVec<
            candidate::EligibleCandidate<Candidate<T>, T::Balance>,
            T::EligibleCandidatesBufferSize,
        >,
        ValueQuery,
    >;

    /// Pools balances.
    #[pallet::storage]
    pub type Pools<T: Config> = StorageDoubleMap<
        _,
        Blake2_128Concat,
        Candidate<T>,
        Blake2_128Concat,
        PoolsKey<T::AccountId>,
        T::Balance,
        ValueQuery,
    >;

    /// Pending operations balances.
    #[pallet::storage]
    pub type PendingOperations<T: Config> = StorageDoubleMap<
        _,
        Blake2_128Concat,
        Delegator<T>,
        Blake2_128Concat,
        PendingOperationKey<T::AccountId, T::BlockNumber>,
        T::Balance,
        ValueQuery,
    >;

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Stake of that Candidate increased.
        UpdatedCandidatePosition {
            candidate: Candidate<T>,
            stake: T::Balance,
            self_delegation: T::Balance,
            before: Option<u32>,
            after: Option<u32>,
        },
        /// Stake of that Candidate increased.
        IncreasedStake {
            candidate: Candidate<T>,
            stake: T::Balance,
        },
        /// Stake of that Candidate decreased.
        DecreasedStake {
            candidate: Candidate<T>,
            stake: T::Balance,
        },
        /// Delegator staked towards a Candidate for AutoCompounding Shares.
        StakedAutoCompounding {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator unstaked towards a candidate with AutoCompounding Shares.
        UnstakedAutoCompounding {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator staked towards a candidate for ManualClaim Shares.
        StakedManualClaim {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator unstaked towards a candidate with ManualClaim Shares.
        UnstakedManualClaim {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Collator has been rewarded.
        RewardedCollator {
            collator: Candidate<T>,
            auto_compounding_rewards: T::Balance,
            manual_claim_rewards: T::Balance,
        },
        /// Delegators have been rewarded.
        RewardedDelegators {
            collator: Candidate<T>,
            auto_compounding_rewards: T::Balance,
            manual_claim_rewards: T::Balance,
        },
        /// Rewards manually claimed.
        ClaimedManualRewards {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            rewards: T::Balance,
        },
        /// Registered delayed leaving from staking towards this candidate.
        RegisteredLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            total_leaving_shares: T::Balance,
        },
        /// Executed delayed leaving from staking towards this candidate.
        ExecutedLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            requested_at: T::BlockNumber,
        },
        /// Canceled delayed leaving from staking towards this candidate.
        CanceledLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            requested_at: T::BlockNumber,
        },
        /// Transfered AutoCompounding shares to another account.
        TransferedAutoCompounding {
            candidate: Candidate<T>,
            sender: Delegator<T>,
            recipient: Delegator<T>,
            shares: T::Balance,
        },
        /// Transfered ManualClaim shares to another account.
        TransferedManualClaim {
            candidate: Candidate<T>,
            sender: Delegator<T>,
            recipient: Delegator<T>,
            shares: T::Balance,
        },
    }

    #[pallet::error]
    pub enum Error<T> {
        InvalidPalletSetting,
        DisabledFeature,
        NoOneIsStaking,
        StakeMustBeNonZero,
        RewardsMustBeNonZero,
        MathUnderflow,
        MathOverflow,
        NotEnoughShares,
        TryingToLeaveTooSoon,
        InconsistentState,
        UnsufficientSharesForTransfer,
        CandidateTransferingOwnSharesForbidden,
        RequestCannotBeExecuted(u32),
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        // TODO: Calls
    }
}
