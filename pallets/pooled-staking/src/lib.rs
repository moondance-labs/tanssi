// Copyright (C) Moondance Labs Ltd.
// This file is part of Tanssi.

// Tanssi is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.

// Tanssi is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.

// You should have received a copy of the GNU General Public License
// along with Tanssi.  If not, see <http://www.gnu.org/licenses/>

//! A staking pallet based on pools of shares.
//!
//! This pallet works with pools inspired by AMM liquidity pools to easily distribute
//! rewards with support for both non-compounding and compounding rewards.
//!
//! Each candidate internally have 3 pools:
//! - a pool for all delegators willing to auto compound.
//! - a pool for all delegators not willing to auto compound.
//! - a pool for all delegators that are in the process of removing stake.
//!
//! When delegating the funds of the delegator are transfered to the `StakingAccount`, and
//! it gets shares in the appropriate pool. Shares allow to easily distribute auto compounding
//! rewards (by simply increasing the total shared amount) and easily slash (each share loose
//! part of its value).
//!

#![cfg_attr(not(feature = "std"), no_std)]

mod pools;
pub mod traits;

use frame_support::pallet;

pub use pallet::*;

#[pallet]
pub mod pallet {
    use {
        super::*,
        core::marker::PhantomData,
        frame_support::{
            storage::types::{StorageMap, StorageValue, ValueQuery},
            traits::{tokens::Balance, Currency, IsType, ReservableCurrency},
            Blake2_128Concat, RuntimeDebug,
        },
        parity_scale_codec::{Decode, Encode, FullCodec},
        scale_info::TypeInfo,
        sp_core::Get,
        sp_runtime::Perbill,
        sp_std::collections::btree_set::BTreeSet,
    };

    #[cfg(feature = "std")]
    use serde::{Deserialize, Serialize};

    // Type aliases for better readability.
    pub type Candidate<T> = <T as frame_system::Config>::AccountId;
    pub type Delegator<T> = <T as frame_system::Config>::AccountId;

    /// Eligible candidate with its stake.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub struct EligibleCandidate<C, S> {
        candidate: C,
        stake: S,
    }

    /// Allow to customize when requests can be executed.
    pub trait RequestFilter<T: Config> {
        fn can_be_executed(
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            request_block: T::BlockNumber,
        ) -> bool;
    }

    /// Key used by the `Pools` StorageMap, avoiding lots of maps.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub enum PoolsKeyRaw<A: FullCodec, B: FullCodec> {
        /// Total amount of currency backing this candidate across all pools.
        CandidateTotalStake { candidate: A },

        /// Amount of auto compounding shares a delegator have for that candidate.
        AutoCompoundingShares { candidate: A, delegator: A },
        /// Total amount of auto compounding shares existing for that candidate.
        AutoCompoundingSharesSupply { candidate: A },
        /// Amount of currency backing all the auto compounding shares of that candidate.
        AutoCompoundingSharesTotalStaked { candidate: A },

        /// Amount of manual rewards shares a delegator have for that candidate.
        ManualRewardsShares { candidate: A, delegator: A },
        /// Total amount of manual rewards shares existing for that candidate.
        ManualRewardsSharesSupply { candidate: A },
        /// Amount of currency backing all the manual rewards shares of that candidate.
        ManualRewardsTotalStaked { candidate: A },
        /// Counter of the cumulated rewards per share generated by that candidate since genesis.
        /// Is safe to wrap around the maximum value of the balance type.
        ManualRewardsCounter { candidate: A },
        /// Value of the counter at the last time the delegator claimed its rewards or changed its amount of shares
        /// (changing the amount of shares automatically claims pending rewards).
        /// The difference between the checkpoint and the counter is the amount of claimable reward per share for
        /// that delegator.
        ManualRewardsCheckpoint { candidate: A, delegator: A },

        JoiningRequest {
            candidate: A,
            delegator: A,
            request_block: B,
        },

        /// Amount of shares of that delegator in the leaving pool of that candidate.
        /// When leaving delegating funds are placed in the leaving pool until the leaving period is elapsed.
        /// While in the leaving pool the funds are still slashable.
        LeavingShares { candidate: A, delegator: A },
        /// Total amount of leaving shares existing for that candidate.
        LeavingSharesSupply { candidate: A },
        /// Amount of currency backing all the leaving shares of that candidate.
        LeavingSharesTotalStaked { candidate: A },
        /// How much currency was requested to be undelegated at that time.
        LeavingRequest {
            candidate: A,
            delegator: A,
            request_block: B,
        },
    }

    #[allow(type_alias_bounds)] // more readable than fully disambiguated paths
    pub type PoolsKey<T: Config> = PoolsKeyRaw<T::AccountId, T::BlockNumber>;

    /// Allow calls to be performed using either share amounts or stake.
    /// When providing stake, calls will convert them into share amounts that are
    /// worth up to the provided stake. The amount of stake thus will be at most the provided
    /// amount.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub enum SharesOrStake<T> {
        Shares(T),
        Stake(T),
    }

    /// Wrapper type for an amount of shares.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Copy, Clone, TypeInfo)]
    pub struct Shares<T: Config>(pub T::Balance);

    /// Wrapper type for an amount of staked currency.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Copy, Clone, TypeInfo)]
    pub struct Stake<T: Config>(pub T::Balance);

    /// Identifier used when executing a pending leaving request.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub struct ExecuteLeavingQuery<C, D, B> {
        pub candidate: C,
        pub delegator: D,
        pub at_block: B,
    }

    /// Identifier used when canceling a pending leaving request.
    #[cfg_attr(feature = "std", derive(Serialize, Deserialize))]
    #[derive(RuntimeDebug, PartialEq, Eq, Encode, Decode, Clone, TypeInfo)]
    pub struct CancelLeavingQuery<C, B> {
        pub candidate: C,
        pub at_block: B,
    }

    /// Pooled Staking pallet.
    #[pallet::pallet]
    #[pallet::without_storage_info]
    pub struct Pallet<T>(PhantomData<T>);

    #[pallet::config]
    pub trait Config: frame_system::Config {
        /// Overarching event type
        type RuntimeEvent: From<Event<Self>> + IsType<<Self as frame_system::Config>::RuntimeEvent>;
        /// The currency type.
        /// Shares will use the same Balance type.
        type Currency: Currency<Self::AccountId, Balance = Self::Balance>
            + ReservableCurrency<Self::AccountId, Balance = Self::Balance>;

        /// Same as Currency::Balance. Must impl `MulDiv` which perform
        /// multiplication followed by division using a bigger type to avoid
        /// overflows.
        type Balance: Balance + traits::MulDiv;

        /// Account holding Currency of all delegators.
        type StakingAccount: Get<Self::AccountId>;
        /// Account of the reserve.
        type ReserveAccount: Get<Self::AccountId>;

        /// When creating the first Shares for a candidate the supply can be arbitrary.
        /// Picking a value too low will make an higher supply, which means each share will get
        /// less rewards, and rewards calculations will have more impactful rounding errors.
        /// Picking a value too high is a barrier of entry for staking.
        type InitialManualClaimShareValue: Get<Self::Balance>;
        /// When creating the first Shares for a candidate the supply can arbitrary.
        /// Picking a value too high is a barrier of entry for staking, which will increase overtime
        /// as the value of each share will increase due to auto compounding.
        type InitialAutoCompoundingShareValue: Get<Self::Balance>;
        /// Minimum amount of stake a Candidate must delegate (stake) towards itself. Not reaching
        /// this minimum prevents from being elected.
        type MinimumSelfDelegation: Get<Self::Balance>;
        /// When leaving staking the stake is put into leaving pools, and the share of this pool
        /// is stored alongside the current BlockNumber. The user will be able to withdraw the stake
        /// represented by those shares once LeavingDelay has passed.
        /// Shares are used here to allow slashing, as while leaving stake is no longer used for
        /// elections and rewards they must still be at stake in case the candidate misbehave.
        type LeavingDelay: Get<Self::BlockNumber>;

        /// Part of the rewards that will be sent to the reserve.
        type RewardsReserveCommission: Get<Perbill>;
        /// Part of the rewards that will be sent exclusively to the collator.
        type RewardsCollatorCommission: Get<Perbill>;

        /// Condition for when a joining request can be executed.
        type JoiningRequestFilter: RequestFilter<Self>;
        /// Condition for when a leaving request can be executed.
        type LeavingRequestFilter: RequestFilter<Self>;
    }

    /// The final set of collators.
    /// Is the top `MaxCollatorSetSize` of `SortedEligibleCandidates`.
    #[pallet::storage]
    pub type CollatorSet<T: Config> = StorageValue<_, BTreeSet<Candidate<T>>, ValueQuery>;

    /// Maximum size of the collator set.
    #[pallet::storage]
    pub type MaxCollatorSetSize<T: Config> = StorageValue<_, u32, ValueQuery>;

    /// Keeps a list of all eligible candidates, sorted by the amount of stake backing them.
    /// This can be quickly updated using a binary search, and allow to easily take the top
    /// `MaxCollatorSetSize`.
    #[pallet::storage]
    pub type SortedEligibleCandidates<T: Config> =
        StorageValue<_, Vec<EligibleCandidate<Candidate<T>, T::Balance>>, ValueQuery>;

    /// Pools balances.
    #[pallet::storage]
    pub type Pools<T: Config> =
        StorageMap<_, Blake2_128Concat, PoolsKey<T>, T::Balance, ValueQuery>;

    #[pallet::event]
    #[pallet::generate_deposit(pub(super) fn deposit_event)]
    pub enum Event<T: Config> {
        /// Stake of that Candidate increased.
        UpdatedCandidatePosition {
            candidate: Candidate<T>,
            stake: T::Balance,
            self_delegation: T::Balance,
            before: Option<u32>,
            after: Option<u32>,
        },
        /// Stake of that Candidate increased.
        IncreasedStake {
            candidate: Candidate<T>,
            stake: T::Balance,
        },
        /// Stake of that Candidate decreased.
        DecreasedStake {
            candidate: Candidate<T>,
            stake: T::Balance,
        },
        /// Delegator staked towards a Candidate for AutoCompounding Shares.
        StakedAutoCompounding {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator unstaked towards a candidate with AutoCompounding Shares.
        UnstakedAutoCompounding {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator staked towards a candidate for ManualClaim Shares.
        StakedManualClaim {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Delegator unstaked towards a candidate with ManualClaim Shares.
        UnstakedManualClaim {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            shares: T::Balance,
            stake: T::Balance,
        },
        /// Collator has been rewarded.
        RewardedCollator {
            collator: Candidate<T>,
            auto_compounding_rewards: T::Balance,
            manual_claim_rewards: T::Balance,
        },
        /// Delegators have been rewarded.
        RewardedDelegators {
            collator: Candidate<T>,
            auto_compounding_rewards: T::Balance,
            manual_claim_rewards: T::Balance,
        },
        /// Rewards manually claimed.
        ClaimedManualRewards {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            rewards: T::Balance,
        },
        /// Registered delayed leaving from staking towards this candidate.
        RegisteredLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            total_leaving_shares: T::Balance,
        },
        /// Executed delayed leaving from staking towards this candidate.
        ExecutedLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            requested_at: T::BlockNumber,
        },
        /// Canceled delayed leaving from staking towards this candidate.
        CanceledLeaving {
            candidate: Candidate<T>,
            delegator: Delegator<T>,
            stake: T::Balance,
            leaving_shares: T::Balance,
            requested_at: T::BlockNumber,
        },
        /// Transfered AutoCompounding shares to another account.
        TransferedAutoCompounding {
            candidate: Candidate<T>,
            sender: Delegator<T>,
            recipient: Delegator<T>,
            shares: T::Balance,
        },
        /// Transfered ManualClaim shares to another account.
        TransferedManualClaim {
            candidate: Candidate<T>,
            sender: Delegator<T>,
            recipient: Delegator<T>,
            shares: T::Balance,
        },
    }

    #[pallet::error]
    pub enum Error<T> {
        InvalidPalletSetting,
        DisabledFeature,
        NoOneIsStaking,
        StakeMustBeNonZero,
        RewardsMustBeNonZero,
        MathUnderflow,
        MathOverflow,
        NotEnoughShares,
        TryingToLeaveTooSoon,
        InconsistentState,
        UnsufficientSharesForTransfer,
        CandidateTransferingOwnSharesForbidden,
    }

    #[pallet::call]
    impl<T: Config> Pallet<T> {
        // TODO: Calls
    }
}
